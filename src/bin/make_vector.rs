use std::{fs::File, io::{BufRead, BufReader}, io::Write};



fn main() {
    let mut lines = BufReader::new(File::open("asm/vector_aarch64.lst").unwrap()).lines();
    let mut out = File::create("src/aarch64/vector.rs").unwrap();

    let begin = r#"//! This file has been generated by make_vector.rs DO NOT EDIT
//! Update asm/vector.c instead
//! 
use crate::{Cond, Error, Executable, Ins, Type, Vsize, R, V};
use super::{vgen2, vgen3, vgenmem};

pub fn gen_vector_aarch64(code: &mut Vec<u8>, i: Ins) -> Result<(), Error> {
    use Type::*;
    use Vsize::*;
    use Ins::*;
    match i {"#;

    writeln!(out, "{begin}").unwrap();

    loop {
        let Some(line) = lines.next() else { break };
        let line = line.unwrap();

        if let (Some(start), Some(end)) = (line.find("<gen_"), line.find(">")) {
            let Some(next) = lines.next() else { break };
            let Some(ret) = lines.next() else { break };
            if !ret.unwrap().contains("ret") {
                // Multi instruction result is bogus.
                continue;
            }
            let next = next.unwrap();
            let mut splits = line[start..end].split('_');
            let s = [splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap()];
            let mut splits = next.split_ascii_whitespace();
            let n = [splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap()];
            // println!("{s:?} {next}");
            let op = s[1];
            let ty = s[2];
            let vsize = s[3];
            let adjust = s[4];
            let args = match s[5] {
                "3" => "dest, src1, src2",
                "2" => "dest, src",
                "mem" => "v, r, imm",
                _ => unreachable!("{}", s[5]),
            };
            let nargs = s[5];
            let value = n[1];
            writeln!(out, "        {op}({ty}, {vsize}, {args}) => vgen{nargs}(code, 0x{value}-{adjust}, {args}, &i), // {next}").unwrap();
        }
    }
    writeln!(out, "        _ => Err(Error::UnsupportedVectorOperation(i))").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    
}
