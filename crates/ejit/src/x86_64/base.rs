//! This file has been generated by ejit-build DO NOT EDIT
//! Update asm/base.c instead
//! 
use crate::{Cond, Error, Executable, Ins, Type, Vsize, R, V};
use super::{gen_lea, gen_binary, gen_unary, gen_cmp, gen_cmpi, gen_mov, gen_movi, gen_div, gen_shift};

pub fn gen_base_x86_64(code: &mut Vec<u8>, i: &Ins) -> Result<(), Error> {
    use Type::*;
    use Vsize::*;
    use Ins::*;
    match i {
        // 0000000000000000 <gen_Add_lea>:
        // 0:	48 8d 04 00          	lea    (%rax,%rax,1),%rax
        // 4:	c3                   	ret
        Add(dest, src1, src2) => gen_lea(code, &[72, 141, 4, 0], dest, src1, src2, &i),
        // 0000000000000005 <gen_Sub_binary>:
        // 5:	48 29 c0             	sub    %rax,%rax
        // 8:	c3                   	ret
        Sub(dest, src1, src2) => gen_binary(code, &[72, 41, 192], dest, src1, src2, &i),
        // 0000000000000009 <gen_And_binary>:
        // 9:	48 21 c0             	and    %rax,%rax
        // c:	c3                   	ret
        And(dest, src1, src2) => gen_binary(code, &[72, 33, 192], dest, src1, src2, &i),
        // 000000000000000d <gen_Or_binary>:
        // d:	48 09 c0             	or     %rax,%rax
        // 10:	c3                   	ret
        Or(dest, src1, src2) => gen_binary(code, &[72, 9, 192], dest, src1, src2, &i),
        // 0000000000000011 <gen_Xor_binary>:
        // 11:	48 31 c0             	xor    %rax,%rax
        // 14:	c3                   	ret
        Xor(dest, src1, src2) => gen_binary(code, &[72, 49, 192], dest, src1, src2, &i),
        // 0000000000000015 <gen_Mul_binary>:
        // 15:	48 0f af c0          	imul   %rax,%rax
        // 19:	c3                   	ret
        Mul(dest, src1, src2) => gen_binary(code, &[72, 15, 175, 192], dest, src1, src2, &i),
        // 000000000000001a <gen_UDiv_div>:
        // 1a:	48 f7 f0             	div    %rax
        // 1d:	c3                   	ret
        UDiv(dest, src1, src2) => gen_div(code, &[72, 247, 240], dest, src1, src2, &i),
        // 000000000000001e <gen_SDiv_div>:
        // 1e:	48 f7 f8             	idiv   %rax
        // 21:	c3                   	ret
        SDiv(dest, src1, src2) => gen_div(code, &[72, 247, 248], dest, src1, src2, &i),
        // 0000000000000022 <gen_Not_unary>:
        // 22:	48 f7 d0             	not    %rax
        // 25:	c3                   	ret
        Not(dest, src) => gen_unary(code, &[72, 247, 208], dest, src, &i),
        // 0000000000000026 <gen_Neg_unary>:
        // 26:	48 f7 d8             	neg    %rax
        // 29:	c3                   	ret
        Neg(dest, src) => gen_unary(code, &[72, 247, 216], dest, src, &i),
        // 000000000000002a <gen_Movi_movi>:
        // 2a:	48 b8 00 00 00 00 00 	movabs $0x0,%rax
        // 31:	00 00 00
        // 34:	c3                   	ret
        Movi(dest, imm) => gen_movi(code, dest, imm, &i),
        // 0000000000000035 <gen_Mov_mov>:
        // 35:	48 89 c0             	mov    %rax,%rax
        // 38:	c3                   	ret
        Mov(dest, src) => gen_mov(code, dest, src, &i),
        // 0000000000000039 <gen_Cmpi_cmpi>:
        // 39:	48 3d 78 56 34 12    	cmp    $0x12345678,%rax
        // 3f:	c3                   	ret
        Cmpi(src, imm) => gen_cmpi(code, &[72, 61, 120, 86, 52, 18], src, imm, &i),
        // 0000000000000040 <gen_Cmp_cmp>:
        // 40:	48 39 c0             	cmp    %rax,%rax
        // 43:	c3                   	ret
        Cmp(src1, src2) => gen_cmp(code, &[72, 57, 192], src1, src2, &i),
        // 0000000000000044 <gen_Shl_shift>:
        // 44:	48 d3 e0             	shl    %cl,%rax
        // 47:	c3                   	ret
        Shl(dest, src1, src2) => gen_shift(code, &[72, 211, 224], dest, src1, src2, &i),
        // 0000000000000048 <gen_Shr_shift>:
        // 48:	48 d3 e8             	shr    %cl,%rax
        // 4b:	c3                   	ret
        Shr(dest, src1, src2) => gen_shift(code, &[72, 211, 232], dest, src1, src2, &i),
        // 000000000000004c <gen_Sar_shift>:
        // 4c:	48 d3 f8             	sar    %cl,%rax
        // 4f:	c3                   	ret
        Sar(dest, src1, src2) => gen_shift(code, &[72, 211, 248], dest, src1, src2, &i),

        _ => Err(Error::UnsupportedOperation(i.clone()))
    }
}
