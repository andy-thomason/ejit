use std::{fs::File, process::Command, io::Write};



pub fn build_aarch_base() {
    println!("{:?}", std::env::current_dir());
    let out = Command::new("aarch64-linux-gnu-gcc")
        .args(["./asm/base.c", "-c", "-O", "-o", "../../target/a.out"])
        .output().unwrap();
    if !out.status.success() {
        panic!("{}", std::str::from_utf8(&out.stderr).unwrap());
    }

    let out = Command::new("aarch64-linux-gnu-objdump")
        .args(["-d", "../../target/a.out"])
        .output().unwrap();
    if !out.status.success() {
        panic!("{}", std::str::from_utf8(&out.stderr).unwrap());
    }

    let mut lines = out.stdout
        .split(|b| *b == b'\n')
        .map(|line| std::str::from_utf8(line));
    let mut out = File::create("./src/aarch64/base.rs").unwrap();

    let begin = r#"//! This file has been generated by ejit-build DO NOT EDIT
//! Update asm/base.c instead
//! 
use crate::{Cond, Error, Executable, Ins, Type, Vsize, R, V};
use super::{gen2, gen3, gen_ldst, gen_movi, gen_mov, gen_cmpi, gen_cmp};

pub fn gen_base_aarch64(code: &mut Vec<u8>, i: &Ins) -> Result<(), Error> {
    use Type::*;
    use Vsize::*;
    use Ins::*;
    match i {"#;    

    writeln!(out, "{begin}").unwrap();

    loop {
        let Some(label) = lines.next() else { break };
        let label = label.unwrap();

        if let (Some(start), Some(end)) = (label.find("<gen_"), label.find(">")) {
            let Some(line1) = lines.next() else { break };
            let Some(line2) = lines.next() else { break };
            let line1 = line1.unwrap();
            let line2 = line2.unwrap();
            let mut splits = label[start..end].split('_');
            let s = [splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap()];
            let mut splits = line1.split_ascii_whitespace();
            let n = [splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap()];
            // println!("{s:?} {next}");
            let op = s[1];
            let (args, vgen) = match s[2] {
                "unary" => ("dest, src", "gen2"),
                "binary" => ("dest, src1, src2", "gen3"),
                "movi" => ("dest, imm", "gen_movi"),
                "mov" => ("dest, imm", "gen2"),
                "cmpi" => ("dest, imm", "gen_cmpi"),
                "cmp" => ("dest, imm", "gen_cmp"),
                "U8" => ("U8, r, ra, imm", "gen_ldst"),
                "S8" => ("S8, r, ra, imm", "gen_ldst"),
                _ => unreachable!("check vector.c {label}")
            };

            if !line2.contains("\tret") && !line2.contains("\tcset") {
                println!("{label}");
                println!("{line1}");
                println!("{line2}");
                todo!();
            }

            let opcode = n[1];
            writeln!(out, "        {op}({args}) => {vgen}(code, 0x{opcode}, {args}, &i), // {line1}").unwrap();
        }
    }
    writeln!(out, "        _ => Err(Error::UnsupportedOperation(i.clone()))").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
}

pub fn build_aarch_vector() {
    println!("{:?}", std::env::current_dir());
    let out = Command::new("aarch64-linux-gnu-gcc")
        .args(["./asm/vector.c", "-c", "-O", "-o", "../../target/a.out"])
        .output().unwrap();
    if !out.status.success() {
        panic!("{}", std::str::from_utf8(&out.stderr).unwrap());
    }

    let out = Command::new("aarch64-linux-gnu-objdump")
        .args(["-d", "../../target/a.out"])
        .output().unwrap();
    if !out.status.success() {
        panic!("{}", std::str::from_utf8(&out.stderr).unwrap());
    }

    let mut lines = out.stdout
        .split(|b| *b == b'\n')
        .map(|line| std::str::from_utf8(line));
    let mut out = File::create("./src/aarch64/vector.rs").unwrap();

    let begin = r#"//! This file has been generated by eji-build DO NOT EDIT
//! Update asm/vector.c instead
//! 
use crate::{Cond, Error, Executable, Ins, Type, Vsize, R, V};
use super::{vgen2, vgen3, vgenmem};

pub fn gen_vector_aarch64(code: &mut Vec<u8>, i: &Ins) -> Result<(), Error> {
    use Type::*;
    use Vsize::*;
    use Ins::*;
    match i {"#;

    writeln!(out, "{begin}").unwrap();

    loop {
        let Some(line) = lines.next() else { break };
        let line = line.unwrap();

        if let (Some(start), Some(end)) = (line.find("<gen_"), line.find(">")) {
            let Some(next) = lines.next() else { break };
            let Some(ret) = lines.next() else { break };
            if !ret.unwrap().contains("ret") {
                // Multi instruction result is bogus.
                continue;
            }
            let next = next.unwrap();
            let mut splits = line[start..end].split('_');
            let s = [splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap()];
            let mut splits = next.split_ascii_whitespace();
            let n = [splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap()];
            // println!("{s:?} {next}");
            let op = s[1];
            let ty = s[2];
            let vsize = s[3];
            let (args, vgen) = match s[4] {
                "A" => ("dest, src", "vgen2"),
                "B" => ("dest, src", "vgen2"),
                "C" => ("dest, src1, src2", "vgen3"),
                "D" => ("v, r, imm", "vgenmem"),
                _ => unreachable!("check vector.c")
            };
            let opcode = n[1];
            writeln!(out, "        {op}({ty}, {vsize}, {args}) => {vgen}(code, 0x{opcode}, {args}, &i), // {next}").unwrap();
        }
    }
    writeln!(out, "        _ => Err(Error::UnsupportedVectorOperation(i.clone()))").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
}
