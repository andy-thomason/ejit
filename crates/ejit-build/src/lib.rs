use std::{fs::File, process::Command, io::Write};



pub fn build_aarch_base() {
    println!("{:?}", std::env::current_dir());
    let out = Command::new("aarch64-linux-gnu-gcc")
        .args(["crates/ejit-build/asm/base.c", "-c", "-O", "-o", "../../target/a.out"])
        .output().unwrap();
    if !out.status.success() {
        panic!("{}", std::str::from_utf8(&out.stderr).unwrap());
    }

    let out = Command::new("aarch64-linux-gnu-objdump")
        .args(["-d", "../../target/a.out"])
        .output().unwrap();
    if !out.status.success() {
        panic!("{}", std::str::from_utf8(&out.stderr).unwrap());
    }

    let mut lines = out.stdout
        .split(|b| *b == b'\n')
        .map(|line| std::str::from_utf8(line));
    let mut out = File::create("./src/aarch64/base.rs").unwrap();

    let begin = r#"//! This file has been generated by ejit-build DO NOT EDIT
//! Update asm/base.c instead
//! 
use crate::{Cond, Error, Executable, Ins, Type, Vsize, R, V};
use super::{gen2, gen3, gen_ldst, gen_movi, gen_mov, gen_cmpi, gen_cmp, gen_shift, gen_adr};

pub fn gen_base_aarch64(code: &mut Vec<u8>, i: &Ins) -> Result<(), Error> {
    use Type::*;
    use Vsize::*;
    use Ins::*;
    match i {"#;    

    writeln!(out, "{begin}").unwrap();

    loop {
        let Some(label) = lines.next() else { break };
        let label = label.unwrap();

        if let (Some(start), Some(end)) = (label.find("<gen_"), label.find(">")) {
            let Some(line1) = lines.next() else { break };
            let Some(line2) = lines.next() else { break };
            let line1 = line1.unwrap();
            let line2 = line2.unwrap();
            let mut splits = label[start..end].split('_');
            let s = [splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap()];
            let mut splits = line1.split_ascii_whitespace();
            let n = [splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap()];
            // println!("{s:?} {next}");
            let op = s[1];
            let (args, vgen) = match s[2] {
                "unary" => ("dest, src", "gen2"),
                "binary" => ("dest, src1, src2", "gen3"),
                "movi" => ("dest, imm", "gen_movi"),
                "mov" => ("dest, imm", "gen2"),
                "cmpi" => ("dest, imm", "gen_cmpi"),
                "cmp" => ("dest, imm", "gen_cmp"),
                "U8" => ("U8, r, ra, imm", "gen_ldst"),
                "S8" => ("S8, r, ra, imm", "gen_ldst"),
                _ => unreachable!("check vector.c {label}")
            };

            if !line2.contains("\tret") && !line2.contains("\tcset") {
                println!("{label}");
                println!("{line1}");
                println!("{line2}");
                todo!();
            }

            let opcode = n[1];
            writeln!(out, "        {op}({args}) => {vgen}(code, 0x{opcode}, {args}, &i), // {line1}").unwrap();
        }
    }
    writeln!(out, "        _ => Err(Error::UnsupportedOperation(i.clone()))").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
}

pub fn build_aarch_vector() {
    println!("{:?}", std::env::current_dir());
    let out = Command::new("aarch64-linux-gnu-gcc")
        .args(["crates/ejit-build/vector.c", "-c", "-O", "-o", "../../target/a.out"])
        .output().unwrap();
    if !out.status.success() {
        panic!("{}", std::str::from_utf8(&out.stderr).unwrap());
    }

    let out = Command::new("aarch64-linux-gnu-objdump")
        .args(["-d", "../../target/a.out"])
        .output().unwrap();
    if !out.status.success() {
        panic!("{}", std::str::from_utf8(&out.stderr).unwrap());
    }

    let mut lines = out.stdout
        .split(|b| *b == b'\n')
        .map(|line| std::str::from_utf8(line));
    let mut out = File::create("./src/aarch64/vector.rs").unwrap();

    let begin = r#"//! This file has been generated by eji-build DO NOT EDIT
//! Update asm/vector.c instead
//! 
use crate::{Cond, Error, Executable, Ins, Type, Vsize, R, V};
use super::{vgen2, vgen3, vgenmem};

pub fn gen_vector_aarch64(code: &mut Vec<u8>, i: &Ins) -> Result<(), Error> {
    use Type::*;
    use Vsize::*;
    use Ins::*;
    match i {"#;

    writeln!(out, "{begin}").unwrap();

    loop {
        let Some(line) = lines.next() else { break };
        let line = line.unwrap();

        if let (Some(start), Some(end)) = (line.find("<gen_"), line.find(">")) {
            let Some(next) = lines.next() else { break };
            let Some(ret) = lines.next() else { break };
            if !ret.unwrap().contains("ret") {
                // Multi instruction result is bogus.
                continue;
            }
            let next = next.unwrap();
            let mut splits = line[start..end].split('_');
            let s = [splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap()];
            let mut splits = next.split_ascii_whitespace();
            let n = [splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap()];
            // println!("{s:?} {next}");
            let op = s[1];
            let ty = s[2];
            let vsize = s[3];
            let (args, vgen) = match s[4] {
                "A" => ("dest, src", "vgen2"),
                "B" => ("dest, src", "vgen2"),
                "C" => ("dest, src1, src2", "vgen3"),
                "D" => ("v, r, imm", "vgenmem"),
                _ => unreachable!("check vector.c")
            };
            let opcode = n[1];
            writeln!(out, "        {op}({ty}, {vsize}, {args}) => {vgen}(code, 0x{opcode}, {args}, &i), // {next}").unwrap();
        }
    }
    writeln!(out, "        _ => Err(Error::UnsupportedVectorOperation(i.clone()))").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
}

pub fn build_x86_base() {
    println!("{:?}", std::env::current_dir());
    let out = Command::new("x86_64-linux-gnu-as")
        .args(["../ejit-build/asm/x86_64.s", "-c", "-O", "-o", "../../target/a.out"])
        .output().unwrap();
    if !out.status.success() {
        panic!("{}", std::str::from_utf8(&out.stderr).unwrap());
    }

    let out = Command::new("x86_64-linux-gnu-objdump")
        .args(["-d", "../../target/a.out"])
        .output().unwrap();
    if !out.status.success() {
        panic!("{}", std::str::from_utf8(&out.stderr).unwrap());
    }

    let mut lines = out.stdout
        .split(|b| *b == b'\n')
        .map(|line| std::str::from_utf8(line));
    let mut out = File::create("./src/x86_64/base.rs").unwrap();

    let begin = r#"//! This file has been generated by ejit-build DO NOT EDIT
//! Update asm/base.c instead
//! 
use crate::{Cond, Error, Executable, Ins, Type, Vsize, R, V};
use super::{gen_lea, gen_binary, gen_unary, gen_cmp, gen_cmpi, gen_mov, gen_movi, gen_div, gen_shift};

pub fn gen_base_x86_64(code: &mut Vec<u8>, i: &Ins) -> Result<(), Error> {
    use Type::*;
    use Vsize::*;
    use Ins::*;
    match i {"#;    

    let end = r#"
        _ => Err(Error::UnsupportedOperation(i.clone()))
    }
}"#;

    writeln!(out, "{begin}").unwrap();
    loop {
        let Some(label) = lines.next() else { break };
        let label = label.unwrap().trim();

        let (Some(start), Some(end)) = (label.find("<gen_"), label.find(">")) else { continue };
        writeln!(out, "        // {label}").unwrap();
        let mut splits = label[start..end].split('_');
        let s = [splits.next().unwrap(), splits.next().unwrap(), splits.next().unwrap()];

        let mut bytes = vec![];
        while let Some(line) = lines.next() {
            let line = line.unwrap().trim();
            writeln!(out, "        // {line}").unwrap();
            let last = line.split_ascii_whitespace().last().unwrap_or_default();
            if last == "ret" {
                break;
            }
            bytes.extend(line
                .split_ascii_whitespace()
                .skip(1)
                .map(|b| (b, b.as_bytes()))
                .filter_map(|(s, b)| if b.len() == 2 && b[0].is_ascii_hexdigit() && b[1].is_ascii_hexdigit() { Some(u8::from_str_radix(s, 16).unwrap() )} else { None }));
        }

        let op = s[1];
        match s[2] {
            "lea" => {
                let args = "dest, src1, src2";
                // "48", "8d", "04", "37", "lea", "(%rdi,%rsi,1),%rax"]
                writeln!(out, "        {op}({args}) => gen_lea(code, &{bytes:?}, {args}, &i),").unwrap();
            }
            "binary" => {
                let args = "dest, src1, src2";
                writeln!(out, "        {op}({args}) => gen_binary(code, &{bytes:?}, {args}, &i),").unwrap();
            }
            "unary" => {
                let args = "dest, src";
                writeln!(out, "        {op}({args}) => gen_unary(code, &{bytes:?}, {args}, &i),").unwrap();
            }
            "div" => {
                let args = "dest, src1, src2";
                writeln!(out, "        {op}({args}) => gen_div(code, &{bytes:?}, {args}, &i),").unwrap();
            }
            "movi" => {
                let args = "dest, imm";
                writeln!(out, "        {op}({args}) => gen_movi(code, {args}, &i),").unwrap();
            }
            "mov" => {
                let args = "dest, src";
                writeln!(out, "        {op}({args}) => gen_mov(code, {args}, &i),").unwrap();
            }
            "cmpi" => {
                let args = "src, imm";
                writeln!(out, "        {op}({args}) => gen_cmpi(code, &{bytes:?}, {args}, &i),").unwrap();
            }
            "cmp" => {
                let args = "src1, src2";
                writeln!(out, "        {op}({args}) => gen_cmp(code, &{bytes:?}, {args}, &i),").unwrap();
            }
            "shift" => {
                let args = "dest, src1, src2";
                writeln!(out, "        {op}({args}) => gen_shift(code, &{bytes:?}, {args}, &i),").unwrap();
            }
            "adr" => {
                let args = "label";
                writeln!(out, "        {op}({args}) => gen_adr(code, &{bytes:?}, {args}, &i),").unwrap();
            }
            _ => unreachable!("{}", s[2])
        }


        // // println!("{line}");
    }
    writeln!(out, "{end}").unwrap();


}

pub fn build_x86_vector() {
    
}